[![white.png](https://i.loli.net/2019/04/11/5cae134487910.png)](https://github.com/i1123581321/NJU-open-resource)

# $\log n$ Search

## Warm up

> **定义 3.2** 查找问题
>
> * 输入：$n$ 个键值 $\{k_1, k_2, \dots, k_n\}$ ，键值 KEY
> * 输出：是否有某个键值 $k_i = KEY(1 \leqslant i \leqslant n)$

### 查找问题的关键

> search 的关键永远不是 search，而是如何**组织数据**使其查找起来高效
>
> 当查找操作频繁，而待查找元素变化不大时，付出较高代价组织数据在长远上看是**合算**的

* BF：基于遍历线性表查找，性能为 $O(n)$ ，在实际应用中不可接受
* $O(\log n)$ ：做到每次查找将查找空间减半
* $\textcolor{red}{O(1)}$ ：理想情况，实际无法做到，但可通过 hash 使代价降到 $O(1 + \alpha)$

### Binary search over sorted sequence

最基本的二分查找，需要查找空间有序（数组，链表因为访存不是常数时间故不适用二分查找）

BINARY-SEARCH (A[first...last], key):

```pseudocode
if last < first then
	return -1;
int mid := (first + last) / 2;
if key == A[mid] then
	index := mid;
else if key < A[mid] then
	index := BINARY-SEARCH(A[first...mid-1], key);
else
	index := BINARY-SEARCH(A[mid+1...last], key);
return index;
```

在此基础上可产生很多基于二分查找的衍生问题

* find peak number in unimodal array (单峰数组的峰值)
* 在有序的自然数集中寻找最小的不在集合中的自然数
* 在有序整数数组中寻找 $A[i] = i$
* 计算 $\lfloor\sqrt{N}\rfloor$

## Balanced Binary Search Tree

### Binary Search Tree (BST)

### Red-Black Tree (RBT)

